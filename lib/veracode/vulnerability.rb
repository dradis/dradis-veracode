module Veracode
  class Vulnerability
    attr_reader :xml_vulnerability

    def initialize(xml_vulnerability)
      @xml = xml_vulnerability
    end

    # List of supported tags. They can be attributes, simple descendans or
    # collections (e.g. <references/>, <tags/>)
    def supported_tags
      [
        :cve_id, :severity_desc, :cwe_id, :cve_summary, :file_name, :file_path,
        :library, :library_id, :mitigation, :cvss_score, :severity,
        :vulnerability_affects_policy_compliance
      ]
    end

    # This allows external callers (and specs) to check for implemented
    # properties
    def respond_to?(method, include_private=false)
      return true if supported_tags.include?(method.to_sym)
      super
    end

    # This method is invoked by Ruby when a method that is not defined in this
    # instance is called.
    #
    # In our case we inspect the @method@ parameter and try to find the
    # attribute, simple descendent or collection that it maps to in the XML
    # tree.
    def method_missing(method, *args)
      # We could remove this check and return nil for any non-recognized tag.
      # The problem would be that it would make tricky to debug problems with
      # typos. For instance: <>.potr would return nil instead of raising an
      # exception
      unless supported_tags.include?(method)
        super
        return
      end

      method_name = method.to_s

      if method_name == 'mitigation'
        return @xml.xpath('.//*:mitigation').map do |mitigation|
          "#{mitigation.attr('action')}\n#{mitigation.attr('description')}\n#{mitigation.attr('date')}"
        end.join("\n\n")
      end

      # First we try the attributes
      return @xml.attributes[method_name].value if @xml.attributes.key?(method_name)

      # Next we try the parent <component> attributes
      component = @xml.parent.parent
      return component.attributes[method_name].value if component.attributes.key?(method_name)
    end
  end
end
